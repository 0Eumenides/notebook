import{_ as n,M as r,p as h,q as p,R as t,N as i,V as m,t as e,a1 as s}from"./framework-e03faf0e.js";const o={},l=s('<blockquote><p>Li, Maosen, et al. &quot;Dynamic multiscale graph neural networks for 3 d skeleton based human motion prediction.&quot; <em>Proceedings of the IEEE/CVF conference on computer vision and pattern recognition</em>. 2020.</p></blockquote><h1 id="出发点" tabindex="-1"><a class="header-anchor" href="#出发点" aria-hidden="true">#</a> 出发点</h1><p>现有的人体运动预测算法通常只针对单一尺度上的人体结构、姿态和运动过程，即人体的基本单位是每个关节点。</p><p>然而，仅通过细粒度的“关节点级别”建模会放大一些不必要的信息，如采集和传输过程中的扰动和误差。</p><p>而且纯粹基于节点所建立的 graph 只能描述节点之间的二元关系，无法描述多个节点协同运动和群组交互关系。</p><hr><p>因此作者提出使用多尺度的 graph 来更好的学习运动特征。先学习单一尺度的特征，再将多尺度特征进行融合，将多尺度特征进行加权求和，</p><h1 id="模型" tabindex="-1"><a class="header-anchor" href="#模型" aria-hidden="true">#</a> 模型</h1><p>模型的主要流程：</p><ol><li>学习单一尺度的特征</li><li>多尺度特征进行融合</li><li>重复 1，2 两个步骤</li><li>将多尺度特征进行加权求和</li><li>将生成特征用于 GRU 单元，来不断生成未来的关节坐标</li></ol><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/09/image-20230509154031406.png" alt="image-20230509154031406"></p><h2 id="多尺度图计算单元-mgcu" tabindex="-1"><a class="header-anchor" href="#多尺度图计算单元-mgcu" aria-hidden="true">#</a> 多尺度图计算单元（MGCU）</h2><p>MGCU 有两个组件组成：</p><ol><li>单尺度图卷积块，利用单尺度图来提取特征</li><li>跨尺度融合块，利用跨尺度图来将一个尺度的特征转移到另一尺度，以实现不同尺度间的信息融合</li></ol><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/09/image-20230509211524218.png" alt="image-20230509211524218|650"></p><p><strong>==SS-GCB==</strong></p><p>该模块使用一个图卷积来提取空间特征 $$ \\mathbf{X}_{s,\\text{sp}}=\\text{Re}\\mathrm{LU}(\\mathbf{A}_s\\mathbf{X}_s\\mathbf{W}_s+\\mathbf{X}_s\\mathbf{U}<em>s)\\in\\mathbb{R}^{M_s\\times D&#39;</em>\\mathbf{x}} $$ $\\textbf{X}_s\\in\\mathbb{R}^{M_s\\times D_x}$，是尺度 s 上的关节特征，$\\textbf{A}_s\\in\\mathbb{R}^{M_s\\times M_s}$ 是反应关节连接情况的邻接矩阵，由身体的物理连接初始化，矩阵可训练，在训练中不断调整。$\\textbf{W}<em>s,\\textbf{U}<em>s\\in\\mathbb{R}^{D</em>\\textbf{x}\\times D</em>\\textbf{x}&#39;}$ 是 MLPs</p><p>使用时间卷积提取时间特征</p><p>==<strong>CS-FB</strong>==</p><p>跨尺度融合模块使用一个跨尺度图来将一个尺度上的特征转换到另一个尺度上</p><p>设邻接矩阵 $\\textbf{A}<em>{s_1s_2}\\in[0,1]^{M</em>{s_2}\\times M_{s_1}}$，反应了尺度 $s_1$ 的关节点和尺度 $s_2$ 的关节点之间的关系</p><p>$\\textbf{P}<em>{s_1,i}$ 表示 $s_1$ 第 i 个关节点的特征，同理 $\\textbf{P}</em>{s_2,j}$</p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/09/image-20230509213653686.png" alt="image-20230509213653686"></p><p>$[\\cdot,\\cdot]$ 表示拼接，先通过 2 a、2 b，2 c、2 d 学习到具有全局相对信息的特征，在对两个尺度的特征矩阵相乘，得到 $\\textbf{A}_{s_1s_2}$ 邻接矩阵，下图展示了完整的流程</p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/09/image-20230509214553582.png" alt="image-20230509214553582"></p><p>有了 $\\textbf{A}<em>{s_1s_2}$ 邻接矩阵后，就可以使用图卷积来将 $s_1$ 尺度下的特征转化到 $s_2$ 尺度上来，再与原来的 $s_2$ 尺度特征相加，就得到了融合了 $s_1$ 尺度的 $s_2$ 尺度特征 $$ \\textbf{X}</em>{s_2}\\leftarrow\\textbf{A}<em>{s_1s_2}\\textbf{X}</em>{s_1}\\textbf{W}<em>{\\text{F},s_1}+\\textbf{X}</em>{s_2}\\in\\mathbb{R}^{M_{s_2}\\times D&#39;<em>\\textbf{x}} $$ $\\mathbf{W}</em>{\\mathrm{F},s_1} \\in \\mathbb{R}^{D_x&#39;\\times D_x}$ 是 MLPs</p><h2 id="graph-based-gru" tabindex="-1"><a class="header-anchor" href="#graph-based-gru" aria-hidden="true">#</a> Graph-based GRU</h2><p>模型使用基于图的 GRU 循环单元来学习和更新隐藏状态 $\\textbf{H}^{(t)}\\in\\mathbb{R}^{M\\times D_{\\text{h}}}$，从而进一步计算关节信息 $\\textbf{I}^{(t)}\\in\\mathbb{R}^{M\\times d}$，这里的 d 不是关节坐标 xyz，而是坐标+速度+加速度等信息 $$ \\begin{aligned} \\textbf{r}^{(t)}&amp; =\\sigma(r_\\mathrm{in}(\\mathbf{I}^{(t)})+r_\\mathrm{hid}(\\mathbf{A}<em>\\mathrm{H}\\mathbf{H}^{(t)}\\mathbf{W}</em>\\mathrm{H})), \\ \\textbf{u}^{(t)}&amp; =\\sigma(u_{\\mathrm{in}}(\\mathbf{I}^{(t)})+u_{\\mathrm{hid}}(\\mathbf{A}<em>{\\mathrm{H}}\\mathbf{H}^{(t)}\\mathbf{W}</em>{\\mathrm{H}})), \\ \\textbf{c}^{(t)}&amp; =\\tanh(c_{\\text{in}}(\\mathbf{I}^{(t)})+\\mathbf{r}^{(t)}\\odot c_{\\text{hid}}(\\mathbf{A}<em>{\\text{H}}\\mathbf{H}^{(t)}\\mathbf{W}</em>{\\text{H}})), \\ \\textbf{H}^{(t+1)}&amp; =\\mathbf{u}^{(t)}\\odot\\mathbf{H}^{(t)}+(1-\\mathbf{u}^{(t)})\\odot\\mathbf{c}^{(t)}, \\end{aligned} $$ $r_{\\text{in}}(\\cdot),r_{\\text{hid}}(\\cdot),u_{\\text{in}}(\\cdot),u_{\\text{hid}}(\\cdot),c_{\\text{in}}(\\cdot)c_{\\text{hid}}(\\cdot)$ 和 $W_H$ 都是 MLPs</p><h2 id="差分操作" tabindex="-1"><a class="header-anchor" href="#差分操作" aria-hidden="true">#</a> 差分操作</h2><p>令 $\\Delta^0\\textbf{X}^{(t)}=\\textbf{X}^{(t)}\\in\\mathbb{R}^{M\\times D_\\textbf{x}}$，$\\begin{aligned} \\Delta^{\\beta}\\textbf{X}^{(t)}&amp; =\\Delta^{\\beta-1}\\textbf{X}^{(t)}-\\Delta^{\\beta-1}\\textbf{X}^{(t-1)} \\end{aligned}$</p><p>差分是边界情况使用 0 填充，因此差分操作为： $$ \\text{diff}_{\\beta}(\\mathbf{X}^{(t)})=\\begin{bmatrix}\\Delta^0\\textbf{X}^{(t)}&amp;\\cdots&amp;\\Delta^{\\beta}\\textbf{X}^{(t)}\\ \\end{bmatrix} $$ 论文使用 $\\beta=2$，因此会得到三个元素，分别是位置，速度，加速度</p><h2 id="模型总览" tabindex="-1"><a class="header-anchor" href="#模型总览" aria-hidden="true">#</a> 模型总览</h2><p><strong>==Encoder==</strong></p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/09/image-20230509220912558.png" alt="image-20230509220912558"></p><ol><li><p>将骨架坐标转化为三阶差分</p></li><li><p>粗尺度的特征为相应细尺度关节特征的平均</p></li><li><p>将三个尺度输入到 MGCU</p></li><li><p>最后将三个尺度的特征加权求和（由于粗粒度关节点少，因此将粗粒度关节特征广播到细粒度） $$ \\mathbb{H}=\\mathbb{H}<em>{s_1}+\\lambda(\\mathbb{H}</em>{s_2}+\\mathbb{H}<em>{s_3}) $$ $\\lambda$ 是超参数，$\\mathbb{H}</em>{s_1},\\mathbb{H}<em>{s_2},\\mathbb{H}</em>{s_3}\\in\\mathbb{R}^{T&#39;\\times M\\times D_{\\text{h}}}$</p></li><li><p>最后使用一个时间平均池化来移除时间维度，得到 $\\begin{aligned}\\textbf{H}&amp; \\in\\mathbb{R}^{M\\times D_{\\mathbf{h}}} \\end{aligned}$</p></li></ol><p>==<strong>Decoder</strong>==</p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/09/image-20230509221732546.png" alt="image-20230509221732546|550"></p><ol><li><p>先根据坐标获得三阶差分</p></li><li><p>利用三阶差分和上一时间的隐藏状态输入 GRU 得到当前时间隐藏状态</p></li><li><p>再将隐藏状态通过 MLP 求的坐标 offsets，与当前时刻的坐标相加，就得到了下一时刻的坐标 $$ \\widehat{\\mathbf{X}}^{(t+1)}=\\widehat{\\mathbf{X}}^{(t)}+f_{\\text{pred}}\\left(\\text{G-GRU}\\left(\\text{diff}<em>2(\\widehat{\\mathbf{X}}^{(t)}),\\mathbf{H}^{(t)}\\right)\\right) $$ $f</em>{\\text{pred}}$ 是 MLPs</p></li></ol><p><strong>==Loss function==</strong></p><p>损失函数使用 $l_1$ 损失，对于拥有小 loss 的关节来说，可以提供足够的梯度，对于拥有大 loss 的关节来说，也可以提供稳定的梯度 $$ \\mathcal{L}<em>{\\text{pred}}=\\frac{1}{N}\\sum</em>{n=1}^N\\left|(\\mathbb{X}<em>{1:T</em>\\mathfrak{f}})<em>n-(\\widehat{\\mathbb{X}}</em>{1:T_\\mathfrak{f}})_n\\right|_1 $$ $N$ 是样本数，公式表示对所有样本的预测坐标与真实坐标求 $l_1$ loss，再取平均</p><h1 id="实验" tabindex="-1"><a class="header-anchor" href="#实验" aria-hidden="true">#</a> 实验</h1><h2 id="数据集" tabindex="-1"><a class="header-anchor" href="#数据集" aria-hidden="true">#</a> 数据集</h2><p>本文使用数据集包含了：</p>',43),c=t("p",null,"将关节坐标转换为指数映射 (exponential maps，是一种描述 3 D 旋转的方式，非零指数映射的关节表示这些关节在运动中确实发生了旋转)，并且只使用非零值的关节 (剩下 20 个关节)，同时在时间维度上，下采样了两倍",-1),b=t("p",null,"只保留了有非零指数映射的 26 个关节，选择了8种详细的动作进行分析：'篮球'，'篮球手势'，'指挥交通'，'跳跃'，'跑步'，'足球'，'走路'和'擦窗户'",-1),d=s('<h2 id="设置" tabindex="-1"><a class="header-anchor" href="#设置" aria-hidden="true">#</a> 设置</h2><ol><li><strong>尺度设置</strong>：设置了3个尺度，包括身体关节，10个和5个身体组件，这适用于两个数据集。</li><li><strong>MGCUs</strong>：使用了4个级联的MGCUs（Multi-Scale Graph Convolution Units），特征维度分别为32，64，128和256。在前两个MGCUs中，他们使用SS-GCBs（Self-Similarity Graph Convolution Blocks）和CS-FBs（Cross-Scale Fusion Blocks）来提取时空特征和融合跨尺度特征；在最后两个MGCUs中，他们只使用SS-GCBs。</li><li><strong>解码器</strong>：在解码器中，G-GRU（Gated Graph Recurrent Unit）的维度是256，使用了一个两层的多层感知器（MLP）来输出姿态。</li><li><strong>训练设置</strong>：在训练过程中，他们设置了批大小为32，并将梯度剪切到最大的l2范数为0.5；使用了Adam优化器，学习率为0.0001。</li><li><strong>超参数选择</strong>：所有的超参数都是通过验证集来选择的</li><li><strong>实现平台</strong>：他们使用PyTorch 1.0实现了DMGNN模型，并在一块RTX-2080Ti GPU上进行训练。</li></ol><h2 id="方法比较" tabindex="-1"><a class="header-anchor" href="#方法比较" aria-hidden="true">#</a> 方法比较</h2>',3),g=s('<p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/10/image-20230510163006082.png" alt="image-20230510163006082"></p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/10/image-20230510163259601.png" alt="image-20230510163259601"></p><p>比较了论文模型与其他先进的模型在**==短期运动预测==**（预测未来500毫秒内的姿态）上的表现，基本上达到了SOTA的性能，但在Discussion和Directions上表现还不足</p><p>在**==长期运动预测==**上，DMGNN也提供了不错的表现</p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/10/image-20230510163657814.png" alt="image-20230510163657814"></p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/10/image-20230510163711528.png" alt="image-20230510163711528"></p><p>同时在==<strong>耗时</strong>==方面，DMGNN也取得了最好的效果</p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/10/image-20230510163856410.png" alt="image-20230510163856410"></p><p>结果表明，所提出的模型在短期和长期预测方面的有效性和效率都优于大多数最先进的方法。</p><h2 id="消融实验" tabindex="-1"><a class="header-anchor" href="#消融实验" aria-hidden="true">#</a> 消融实验</h2><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/10/image-20230510164040964.png" alt="image-20230510164040964"></p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/10/image-20230510164102326.png" alt="image-20230510164102326"></p><hr><p>模型对三个尺度特征加权求和的超参数$\\lambda$具有鲁棒性</p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/10/image-20230510164507453.png" alt="image-20230510164507453"></p><hr><p>最后作者还做出了一下分析</p><ol><li><p><strong>验证DMGNN的特征学习能力</strong>：作者首先测试了DMGNN模型学习到的跨尺度图表（cross-scale graphs）对不同动作的区分能力。他们展示了H3.6M数据集中&#39;Walking&#39;和&#39;Directions&#39;两种动作在两个CS-FBs（Cross-Scale Fusion Blocks）中的图表。对于每种动作，他们展示了从详细尺度到粗尺度右臂的一些强关联。从结果中，他们发现i) 对于每种动作，CS-FBs都能捕捉到人体的各种范围：第一个CS-FB主要关注附近的身体组件，第二个CS-FB捕捉到更全局和与动作相关的影响，例如在走路时，手和脚影响到手臂；ii) 对于不同的动作，跨尺度图是不同的，特别是在第二个CS-FB中，捕捉到了不同的模式。</p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/10/image-20230510165008873.png" alt="image-20230510165008873"></p></li><li><p><strong>动作分类测试</strong>：然后，他们在中间表示上进行动作分类，以测试模型的区分能力。他们单独训练了一个两层的多层感知器（MLP）来对每个动态的跨尺度图进行分类。他们还分类了来自DMGNN、Res-sup（有类别的）和TP-RNN（无类别的）的编码器的输出。表10展示了对15种动作类别的平均分类准确率。他们发现，第二个CS-FB中的跨尺度图比第一个CS-FB中的对动作识别更有信息量。与基线方法相比，DMGNN在编码器表示上获得了最高的分类准确率，这表明DMGNN捕捉到了对无类别预测有区分性的信息。</p><p><img src="https://raw.githubusercontent.com/0Eumenides/upic/main/2023/05/10/image-20230510165110939.png" alt="image-20230510165110939"></p></li></ol>',18);function u(_,f){const a=r("RouterLink");return h(),p("div",null,[l,t("ol",null,[t("li",null,[t("p",null,[i(a,{to:"/%E7%A7%91%E7%A0%94/%E6%95%B0%E6%8D%AE%E9%9B%86/Human3.6M.html"},{default:m(()=>[e("Human3.6M")]),_:1})]),c]),t("li",null,[t("p",null,[i(a,{to:"/%E7%A7%91%E7%A0%94/%E6%95%B0%E6%8D%AE%E9%9B%86/CMU%20motion%20capture.html"},{default:m(()=>[e("CMU motion capture")]),_:1})]),b])]),d,t("p",null,[e("评价指标上选用 mean angle error ("),i(a,{to:"/%E7%A7%91%E7%A0%94/tricks/MAE.html"},{default:m(()=>[e("MAE")]),_:1}),e(")")]),g])}const x=n(o,[["render",u],["__file","Dynamic Multiscale Graph Neural Networks for 3D Skeleton-Based Human Motion Prediction.html.vue"]]);export{x as default};
